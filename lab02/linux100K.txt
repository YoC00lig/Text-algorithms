static void fore200e_param_bs_queue(struct fore200e *fore200e,
				    enum buffer_scheme scheme,
				    enum buffer_magn magn, int queue_length,
				    int pool_size, int supply_blksize)
{
    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];

    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
}


static int fore200e_initialize(struct fore200e *fore200e)
{
    struct cp_queues __iomem * cpq;
    int               ok, scheme, magn;

    DPRINTK(2, "device %s being initialized\n", fore200e->name);

    mutex_init(&fore200e->rate_mtx);
    spin_lock_init(&fore200e->q_lock);

    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;

    /* enable cp to host interrupts */
    fore200e->bus->write(1, &cpq->imask);

    if (fore200e->bus->irq_enable)
	fore200e->bus->irq_enable(fore200e);
    
    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);

    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);

    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);

    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)
	for (magn = 0; magn < BUFFER_MAGN_NBR; magn++)
	    fore200e_param_bs_queue(fore200e, scheme, magn,
				    QUEUE_SIZE_BS, 
				    fore200e_rx_buf_nbr[ scheme ][ magn ],
				    RBD_BLK_SIZE);

    /* issue the initialize command */
    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);

    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);
    if (ok == 0) {
	printk(FORE200E "device %s initialization failed\n", fore200e->name);
	return -ENODEV;
    }

    printk(FORE200E "device %s initialized\n", fore200e->name);

    fore200e->state = FORE200E_STATE_INITIALIZE;
    return 0;
}


static void fore200e_monitor_putc(struct fore200e *fore200e, char c)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;

#if 0
    printk("%c", c);
#endif
    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
}


static int fore200e_monitor_getc(struct fore200e *fore200e)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;
    unsigned long      timeout = jiffies + msecs_to_jiffies(50);
    int                c;

    while (time_before(jiffies, timeout)) {

	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);

	if (c & FORE200E_CP_MONITOR_UART_AVAIL) {

	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
#if 0
	    printk("%c", c & 0xFF);
#endif
	    return c & 0xFF;
	}
    }

    return -1;
}


static void fore200e_monitor_puts(struct fore200e *fore200e, char *str)
{
    while (*str) {

	/* the i960 monitor doesn't accept any new character if it has something to say */
	while (fore200e_monitor_getc(fore200e) >= 0);
	
	fore200e_monitor_putc(fore200e, *str++);
    }

    while (fore200e_monitor_getc(fore200e) >= 0);
}

#ifdef __LITTLE_ENDIAN
#define FW_EXT ".bin"
#else
#define FW_EXT "_ecd.bin2"
#endif

static int fore200e_load_and_start_fw(struct fore200e *fore200e)
{
    const struct firmware *firmware;
    const struct fw_header *fw_header;
    const __le32 *fw_data;
    u32 fw_size;
    u32 __iomem *load_addr;
    char buf[48];
    int err;

    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {
	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
	return err;
    }

    fw_data = (const __le32 *)firmware->data;
    fw_size = firmware->size / sizeof(u32);
    fw_header = (const struct fw_header *)firmware->data;
    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);

    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",
	    fore200e->name, load_addr, fw_size);

    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {
	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
	goto release;
    }

    for (; fw_size--; fw_data++, load_addr++)
	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);

    DPRINTK(2, "device %s firmware being started\n", fore200e->name);

#if defined(__sparc_v9__)
    /* reported to be required by SBA cards on some sparc64 hosts */
    fore200e_spin(100);
#endif

    sprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));
    fore200e_monitor_puts(fore200e, buf);

    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {
	printk(FORE200E "device %s firmware didn't start\n", fore200e->name);
	goto release;
    }

    printk(FORE200E "device %s firmware started\n", fore200e->name);

    fore200e->state = FORE200E_STATE_START_FW;
    err = 0;

release:
    release_firmware(firmware);
    return err;
}


static int fore200e_register(struct fore200e *fore200e, struct device *parent)
{
    struct atm_dev* atm_dev;

    DPRINTK(2, "device %s being registered\n", fore200e->name);

    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
                               -1, NULL);
    if (atm_dev == NULL) {
	printk(FORE200E "unable to register device %s\n", fore200e->name);
	return -ENODEV;
    }

    atm_dev->dev_data = fore200e;
    fore200e->atm_dev = atm_dev;

    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;
    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;

    fore200e->available_cell_rate = ATM_OC3_PCR;

    fore200e->state = FORE200E_STATE_REGISTER;
    return 0;
}


static int fore200e_init(struct fore200e *fore200e, struct device *parent)
{
    if (fore200e_register(fore200e, parent) < 0)
	return -ENODEV;
    
    if (fore200e->bus->configure(fore200e) < 0)
	return -ENODEV;

    if (fore200e->bus->map(fore200e) < 0)
	return -ENODEV;

    if (fore200e_reset(fore200e, 1) < 0)
	return -ENODEV;

    if (fore200e_load_and_start_fw(fore200e) < 0)
	return -ENODEV;

    if (fore200e_initialize(fore200e) < 0)
	return -ENODEV;

    if (fore200e_init_cmd_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_tx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_rx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_bs_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_alloc_rx_buf(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_get_esi(fore200e) < 0)
	return -EIO;

    if (fore200e_irq_request(fore200e) < 0)
	return -EBUSY;

    fore200e_supply(fore200e);

    /* all done, board initialization is now complete */
    fore200e->state = FORE200E_STATE_COMPLETE;
    return 0;
}

#ifdef CONFIG_SBUS
static const struct of_device_id fore200e_sba_match[];
static int fore200e_sba_probe(struct platform_device *op)
{
	const struct of_device_id *match;
	struct fore200e *fore200e;
	static int index = 0;
	int err;

	match = of_match_device(fore200e_sba_match, &op->dev);
	if (!match)
		return -EINVAL;

	fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
	if (!fore200e)
		return -ENOMEM;

	fore200e->bus = &fore200e_sbus_ops;
	fore200e->dev = &op->dev;
	fore200e->irq = op->archdata.irqs[0];
	fore200e->phys_base = op->resource[0].start;

	sprintf(fore200e->name, "SBA-200E-%d", index);

	err = fore200e_init(fore200e, &op->dev);
	if (err < 0) {
		fore200e_shutdown(fore200e);
		kfree(fore200e);
		return err;
	}

	index++;
	dev_set_drvdata(&op->dev, fore200e);

	return 0;
}

static int fore200e_sba_remove(struct platform_device *op)
{
	struct fore200e *fore200e = dev_get_drvdata(&op->dev);

	fore200e_shutdown(fore200e);
	kfree(fore200e);

	return 0;
}

static const struct of_device_id fore200e_sba_match[] = {
	{
		.name = SBA200E_PROM_NAME,
	},
	{},
};
MODULE_DEVICE_TABLE(of, fore200e_sba_match);

static struct platform_driver fore200e_sba_driver = {
	.driver = {
		.name = "fore_200e",
		.of_match_table = fore200e_sba_match,
	},
	.probe		= fore200e_sba_probe,
	.remove		= fore200e_sba_remove,
};
#endif

#ifdef CONFIG_PCI
static int fore200e_pca_detect(struct pci_dev *pci_dev,
			       const struct pci_device_id *pci_ent)
{
    struct fore200e* fore200e;
    int err = 0;
    static int index = 0;

    if (pci_enable_device(pci_dev)) {
	err = -EINVAL;
	goto out;
    }

    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {
	err = -EINVAL;
	goto out;
    }
    
    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
    if (fore200e == NULL) {
	err = -ENOMEM;
	goto out_disable;
    }

    fore200e->bus       = &fore200e_pci_ops;
    fore200e->dev	= &pci_dev->dev;
    fore200e->irq       = pci_dev->irq;
    fore200e->phys_base = pci_resource_start(pci_dev, 0);

    sprintf(fore200e->name, "PCA-200E-%d", index - 1);

    pci_set_master(pci_dev);

    printk(FORE200E "device PCA-200E found at 0x%lx, IRQ %s\n",
	   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));

    sprintf(fore200e->name, "PCA-200E-%d", index);

    err = fore200e_init(fore200e, &pci_dev->dev);
    if (err < 0) {
	fore200e_shutdown(fore200e);
	goto out_free;
    }

    ++index;
    pci_set_drvdata(pci_dev, fore200e);

out:
    return err;

out_free:
    kfree(fore200e);
out_disable:
    pci_disable_device(pci_dev);
    goto out;
}


static void fore200e_pca_remove_one(struct pci_dev *pci_dev)
{
    struct fore200e *fore200e;

    fore200e = pci_get_drvdata(pci_dev);

    fore200e_shutdown(fore200e);
    kfree(fore200e);
    pci_disable_device(pci_dev);
}


static const struct pci_device_id fore200e_pca_tbl[] = {
    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);

static struct pci_driver fore200e_pca_driver = {
    .name =     "fore_200e",
    .probe =    fore200e_pca_detect,
    .remove =   fore200e_pca_remove_one,
    .id_table = fore200e_pca_tbl,
};
#endif

static int __init fore200e_module_init(void)
{
	int err = 0;

	printk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");

#ifdef CONFIG_SBUS
	err = platform_driver_register(&fore200e_sba_driver);
	if (err)
		return err;
#endif

#ifdef CONFIG_PCI
	err = pci_register_driver(&fore200e_pca_driver);
#endif

#ifdef CONFIG_SBUS
	if (err)
		platform_driver_unregister(&fore200e_sba_driver);
#endif

	return err;
}

static void __exit fore200e_module_cleanup(void)
{
#ifdef CONFIG_PCI
	pci_unregister_driver(&fore200e_pca_driver);
#endif
#ifdef CONFIG_SBUS
	platform_driver_unregister(&fore200e_sba_driver);
#endif
}

static int
fore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)
{
    struct fore200e*     fore200e  = FORE200E_DEV(dev);
    struct fore200e_vcc* fore200e_vcc;
    struct atm_vcc*      vcc;
    int                  i, len, left = *pos;
    unsigned long        flags;

    if (!left--) {

	if (fore200e_getstats(fore200e) < 0)
	    return -EIO;

	len = sprintf(page,"\n"
		       " device:\n"
		       "   internal name:\t\t%s\n", fore200e->name);

	/* print bus-specific information */
	if (fore200e->bus->proc_read)
	    len += fore200e->bus->proc_read(fore200e, page + len);
	
	len += sprintf(page + len,
		"   interrupt line:\t\t%s\n"
		"   physical base address:\t0x%p\n"
		"   virtual base address:\t0x%p\n"
		"   factory address (ESI):\t%pM\n"
		"   board serial number:\t\t%d\n\n",
		fore200e_irq_itoa(fore200e->irq),
		(void*)fore200e->phys_base,
		fore200e->virt_base,
		fore200e->esi,
		fore200e->esi[4] * 256 + fore200e->esi[5]);

	return len;
    }

    if (!left--)
	return sprintf(page,
		       "   free small bufs, scheme 1:\t%d\n"
		       "   free large bufs, scheme 1:\t%d\n"
		       "   free small bufs, scheme 2:\t%d\n"
		       "   free large bufs, scheme 2:\t%d\n",
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);

    if (!left--) {
	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);

	len = sprintf(page,"\n\n"
		      " cell processor:\n"
		      "   heartbeat state:\t\t");
	
	if (hb >> 16 != 0xDEAD)
	    len += sprintf(page + len, "0x%08x\n", hb);
	else
	    len += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);

	return len;
    }

    if (!left--) {
	static const char* media_name[] = {
	    "unshielded twisted pair",
	    "multimode optical fiber ST",
	    "multimode optical fiber SC",
	    "single-mode optical fiber ST",
	    "single-mode optical fiber SC",
	    "unknown"
	};

	static const char* oc3_mode[] = {
	    "normal operation",
	    "diagnostic loopback",
	    "line loopback",
	    "unknown"
	};

	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
	u32 oc3_index;

	if (media_index > 4)
		media_index = 5;
	
	switch (fore200e->loop_mode) {
	    case ATM_LM_NONE:    oc3_index = 0;
		                 break;
	    case ATM_LM_LOC_PHY: oc3_index = 1;
		                 break;
	    case ATM_LM_RMT_PHY: oc3_index = 2;
		                 break;
	    default:             oc3_index = 3;
	}

	return sprintf(page,
		       "   firmware release:\t\t%d.%d.%d\n"
		       "   monitor release:\t\t%d.%d\n"
		       "   media type:\t\t\t%s\n"
		       "   OC-3 revision:\t\t0x%x\n"
                       "   OC-3 mode:\t\t\t%s",
		       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,
		       mon960_release >> 16, mon960_release << 16 >> 16,
		       media_name[ media_index ],
		       oc3_revision,
		       oc3_mode[ oc3_index ]);
    }

    if (!left--) {
	struct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;

	return sprintf(page,
		       "\n\n"
		       " monitor:\n"
		       "   version number:\t\t%d\n"
		       "   boot status word:\t\t0x%08x\n",
		       fore200e->bus->read(&cp_monitor->mon_version),
		       fore200e->bus->read(&cp_monitor->bstat));
    }

    if (!left--)
	return sprintf(page,
		       "\n"
		       " device statistics:\n"
		       "  4b5b:\n"
		       "     crc_header_errors:\t\t%10u\n"
		       "     framing_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->phy.crc_header_errors),
		       be32_to_cpu(fore200e->stats->phy.framing_errors));
    
    if (!left--)
	return sprintf(page, "\n"
		       "  OC-3:\n"
		       "     section_bip8_errors:\t%10u\n"
		       "     path_bip8_errors:\t\t%10u\n"
		       "     line_bip24_errors:\t\t%10u\n"
		       "     line_febe_errors:\t\t%10u\n"
		       "     path_febe_errors:\t\t%10u\n"
		       "     corr_hcs_errors:\t\t%10u\n"
		       "     ucorr_hcs_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),
		       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));

    if (!left--)
	return sprintf(page,"\n"
		       "   ATM:\t\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     vpi out of range:\t\t%10u\n"
		       "     vpi no conn:\t\t%10u\n"
		       "     vci out of range:\t\t%10u\n"
		       "     vci no conn:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->atm.cells_transmitted),
		       be32_to_cpu(fore200e->stats->atm.cells_received),
		       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),
		       be32_to_cpu(fore200e->stats->atm.vci_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vci_no_conn));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL0:\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     dropped:\t\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal0.cells_received),
		       be32_to_cpu(fore200e->stats->aal0.cells_dropped));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL3/4:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cells_received),
		       be32_to_cpu(fore200e->stats->aal34.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),
		       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL5:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       congestions:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cells_received),
		       be32_to_cpu(fore200e->stats->aal5.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal5.congestion_experienced),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AUX:\t\t       allocation failures\n"
		       "     small b1:\t\t\t%10u\n"
		       "     large b1:\t\t\t%10u\n"
		       "     small b2:\t\t\t%10u\n"
		       "     large b2:\t\t\t%10u\n"
		       "     RX PDUs:\t\t\t%10u\n"
		       "     TX PDUs:\t\t\t%10lu\n",
		       be32_to_cpu(fore200e->stats->aux.small_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.small_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),
		       fore200e->tx_sat);
    
    if (!left--)
	return sprintf(page,"\n"
		       " receive carrier:\t\t\t%s\n",
		       fore200e->stats->aux.receive_carrier ? "ON" : "OFF!");
    
    if (!left--) {
        return sprintf(page,"\n"
		       " VCCs:\n  address   VPI VCI   AAL "
		       "TX PDUs   TX min/max size  RX PDUs   RX min/max size\n");
    }

    for (i = 0; i < NBR_CONNECT; i++) {

	vcc = fore200e->vc_map[i].vcc;

	if (vcc == NULL)
	    continue;

	spin_lock_irqsave(&fore200e->q_lock, flags);

	if (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {

	    fore200e_vcc = FORE200E_VCC(vcc);
	    ASSERT(fore200e_vcc);

	    len = sprintf(page,
			  "  %pK  %03d %05d %1d   %09lu %05d/%05d      %09lu %05d/%05d\n",
			  vcc,
			  vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),
			  fore200e_vcc->tx_pdu,
			  fore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,
			  fore200e_vcc->tx_max_pdu,
			  fore200e_vcc->rx_pdu,
			  fore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,
			  fore200e_vcc->rx_max_pdu);

	    spin_unlock_irqrestore(&fore200e->q_lock, flags);
	    return len;
	}

	spin_unlock_irqrestore(&fore200e->q_lock, flags);
    }
    
    return 0;
}
static void fore200e_param_bs_queue(struct fore200e *fore200e,
				    enum buffer_scheme scheme,
				    enum buffer_magn magn, int queue_length,
				    int pool_size, int supply_blksize)
{
    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];

    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
}


static int fore200e_initialize(struct fore200e *fore200e)
{
    struct cp_queues __iomem * cpq;
    int               ok, scheme, magn;

    DPRINTK(2, "device %s being initialized\n", fore200e->name);

    mutex_init(&fore200e->rate_mtx);
    spin_lock_init(&fore200e->q_lock);

    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;

    /* enable cp to host interrupts */
    fore200e->bus->write(1, &cpq->imask);

    if (fore200e->bus->irq_enable)
	fore200e->bus->irq_enable(fore200e);
    
    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);

    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);

    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);

    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)
	for (magn = 0; magn < BUFFER_MAGN_NBR; magn++)
	    fore200e_param_bs_queue(fore200e, scheme, magn,
				    QUEUE_SIZE_BS, 
				    fore200e_rx_buf_nbr[ scheme ][ magn ],
				    RBD_BLK_SIZE);

    /* issue the initialize command */
    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);

    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);
    if (ok == 0) {
	printk(FORE200E "device %s initialization failed\n", fore200e->name);
	return -ENODEV;
    }

    printk(FORE200E "device %s initialized\n", fore200e->name);

    fore200e->state = FORE200E_STATE_INITIALIZE;
    return 0;
}


static void fore200e_monitor_putc(struct fore200e *fore200e, char c)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;

#if 0
    printk("%c", c);
#endif
    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
}


static int fore200e_monitor_getc(struct fore200e *fore200e)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;
    unsigned long      timeout = jiffies + msecs_to_jiffies(50);
    int                c;

    while (time_before(jiffies, timeout)) {

	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);

	if (c & FORE200E_CP_MONITOR_UART_AVAIL) {

	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
#if 0
	    printk("%c", c & 0xFF);
#endif
	    return c & 0xFF;
	}
    }

    return -1;
}


static void fore200e_monitor_puts(struct fore200e *fore200e, char *str)
{
    while (*str) {

	/* the i960 monitor doesn't accept any new character if it has something to say */
	while (fore200e_monitor_getc(fore200e) >= 0);
	
	fore200e_monitor_putc(fore200e, *str++);
    }

    while (fore200e_monitor_getc(fore200e) >= 0);
}

#ifdef __LITTLE_ENDIAN
#define FW_EXT ".bin"
#else
#define FW_EXT "_ecd.bin2"
#endif

static int fore200e_load_and_start_fw(struct fore200e *fore200e)
{
    const struct firmware *firmware;
    const struct fw_header *fw_header;
    const __le32 *fw_data;
    u32 fw_size;
    u32 __iomem *load_addr;
    char buf[48];
    int err;

    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {
	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
	return err;
    }

    fw_data = (const __le32 *)firmware->data;
    fw_size = firmware->size / sizeof(u32);
    fw_header = (const struct fw_header *)firmware->data;
    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);

    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",
	    fore200e->name, load_addr, fw_size);

    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {
	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
	goto release;
    }

    for (; fw_size--; fw_data++, load_addr++)
	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);

    DPRINTK(2, "device %s firmware being started\n", fore200e->name);

#if defined(__sparc_v9__)
    /* reported to be required by SBA cards on some sparc64 hosts */
    fore200e_spin(100);
#endif

    sprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));
    fore200e_monitor_puts(fore200e, buf);

    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {
	printk(FORE200E "device %s firmware didn't start\n", fore200e->name);
	goto release;
    }

    printk(FORE200E "device %s firmware started\n", fore200e->name);

    fore200e->state = FORE200E_STATE_START_FW;
    err = 0;

release:
    release_firmware(firmware);
    return err;
}


static int fore200e_register(struct fore200e *fore200e, struct device *parent)
{
    struct atm_dev* atm_dev;

    DPRINTK(2, "device %s being registered\n", fore200e->name);

    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
                               -1, NULL);
    if (atm_dev == NULL) {
	printk(FORE200E "unable to register device %s\n", fore200e->name);
	return -ENODEV;
    }

    atm_dev->dev_data = fore200e;
    fore200e->atm_dev = atm_dev;

    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;
    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;

    fore200e->available_cell_rate = ATM_OC3_PCR;

    fore200e->state = FORE200E_STATE_REGISTER;
    return 0;
}


static int fore200e_init(struct fore200e *fore200e, struct device *parent)
{
    if (fore200e_register(fore200e, parent) < 0)
	return -ENODEV;
    
    if (fore200e->bus->configure(fore200e) < 0)
	return -ENODEV;

    if (fore200e->bus->map(fore200e) < 0)
	return -ENODEV;

    if (fore200e_reset(fore200e, 1) < 0)
	return -ENODEV;

    if (fore200e_load_and_start_fw(fore200e) < 0)
	return -ENODEV;

    if (fore200e_initialize(fore200e) < 0)
	return -ENODEV;

    if (fore200e_init_cmd_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_tx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_rx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_bs_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_alloc_rx_buf(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_get_esi(fore200e) < 0)
	return -EIO;

    if (fore200e_irq_request(fore200e) < 0)
	return -EBUSY;

    fore200e_supply(fore200e);

    /* all done, board initialization is now complete */
    fore200e->state = FORE200E_STATE_COMPLETE;
    return 0;
}

#ifdef CONFIG_SBUS
static const struct of_device_id fore200e_sba_match[];
static int fore200e_sba_probe(struct platform_device *op)
{
	const struct of_device_id *match;
	struct fore200e *fore200e;
	static int index = 0;
	int err;

	match = of_match_device(fore200e_sba_match, &op->dev);
	if (!match)
		return -EINVAL;

	fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
	if (!fore200e)
		return -ENOMEM;

	fore200e->bus = &fore200e_sbus_ops;
	fore200e->dev = &op->dev;
	fore200e->irq = op->archdata.irqs[0];
	fore200e->phys_base = op->resource[0].start;

	sprintf(fore200e->name, "SBA-200E-%d", index);

	err = fore200e_init(fore200e, &op->dev);
	if (err < 0) {
		fore200e_shutdown(fore200e);
		kfree(fore200e);
		return err;
	}

	index++;
	dev_set_drvdata(&op->dev, fore200e);

	return 0;
}

static int fore200e_sba_remove(struct platform_device *op)
{
	struct fore200e *fore200e = dev_get_drvdata(&op->dev);

	fore200e_shutdown(fore200e);
	kfree(fore200e);

	return 0;
}

static const struct of_device_id fore200e_sba_match[] = {
	{
		.name = SBA200E_PROM_NAME,
	},
	{},
};
MODULE_DEVICE_TABLE(of, fore200e_sba_match);

static struct platform_driver fore200e_sba_driver = {
	.driver = {
		.name = "fore_200e",
		.of_match_table = fore200e_sba_match,
	},
	.probe		= fore200e_sba_probe,
	.remove		= fore200e_sba_remove,
};
#endif

#ifdef CONFIG_PCI
static int fore200e_pca_detect(struct pci_dev *pci_dev,
			       const struct pci_device_id *pci_ent)
{
    struct fore200e* fore200e;
    int err = 0;
    static int index = 0;

    if (pci_enable_device(pci_dev)) {
	err = -EINVAL;
	goto out;
    }

    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {
	err = -EINVAL;
	goto out;
    }
    
    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
    if (fore200e == NULL) {
	err = -ENOMEM;
	goto out_disable;
    }

    fore200e->bus       = &fore200e_pci_ops;
    fore200e->dev	= &pci_dev->dev;
    fore200e->irq       = pci_dev->irq;
    fore200e->phys_base = pci_resource_start(pci_dev, 0);

    sprintf(fore200e->name, "PCA-200E-%d", index - 1);

    pci_set_master(pci_dev);

    printk(FORE200E "device PCA-200E found at 0x%lx, IRQ %s\n",
	   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));

    sprintf(fore200e->name, "PCA-200E-%d", index);

    err = fore200e_init(fore200e, &pci_dev->dev);
    if (err < 0) {
	fore200e_shutdown(fore200e);
	goto out_free;
    }

    ++index;
    pci_set_drvdata(pci_dev, fore200e);

out:
    return err;

out_free:
    kfree(fore200e);
out_disable:
    pci_disable_device(pci_dev);
    goto out;
}


static void fore200e_pca_remove_one(struct pci_dev *pci_dev)
{
    struct fore200e *fore200e;

    fore200e = pci_get_drvdata(pci_dev);

    fore200e_shutdown(fore200e);
    kfree(fore200e);
    pci_disable_device(pci_dev);
}


static const struct pci_device_id fore200e_pca_tbl[] = {
    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);

static struct pci_driver fore200e_pca_driver = {
    .name =     "fore_200e",
    .probe =    fore200e_pca_detect,
    .remove =   fore200e_pca_remove_one,
    .id_table = fore200e_pca_tbl,
};
#endif

static int __init fore200e_module_init(void)
{
	int err = 0;

	printk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");

#ifdef CONFIG_SBUS
	err = platform_driver_register(&fore200e_sba_driver);
	if (err)
		return err;
#endif

#ifdef CONFIG_PCI
	err = pci_register_driver(&fore200e_pca_driver);
#endif

#ifdef CONFIG_SBUS
	if (err)
		platform_driver_unregister(&fore200e_sba_driver);
#endif

	return err;
}

static void __exit fore200e_module_cleanup(void)
{
#ifdef CONFIG_PCI
	pci_unregister_driver(&fore200e_pca_driver);
#endif
#ifdef CONFIG_SBUS
	platform_driver_unregister(&fore200e_sba_driver);
#endif
}

static int
fore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)
{
    struct fore200e*     fore200e  = FORE200E_DEV(dev);
    struct fore200e_vcc* fore200e_vcc;
    struct atm_vcc*      vcc;
    int                  i, len, left = *pos;
    unsigned long        flags;

    if (!left--) {

	if (fore200e_getstats(fore200e) < 0)
	    return -EIO;

	len = sprintf(page,"\n"
		       " device:\n"
		       "   internal name:\t\t%s\n", fore200e->name);

	/* print bus-specific information */
	if (fore200e->bus->proc_read)
	    len += fore200e->bus->proc_read(fore200e, page + len);
	
	len += sprintf(page + len,
		"   interrupt line:\t\t%s\n"
		"   physical base address:\t0x%p\n"
		"   virtual base address:\t0x%p\n"
		"   factory address (ESI):\t%pM\n"
		"   board serial number:\t\t%d\n\n",
		fore200e_irq_itoa(fore200e->irq),
		(void*)fore200e->phys_base,
		fore200e->virt_base,
		fore200e->esi,
		fore200e->esi[4] * 256 + fore200e->esi[5]);

	return len;
    }

    if (!left--)
	return sprintf(page,
		       "   free small bufs, scheme 1:\t%d\n"
		       "   free large bufs, scheme 1:\t%d\n"
		       "   free small bufs, scheme 2:\t%d\n"
		       "   free large bufs, scheme 2:\t%d\n",
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);

    if (!left--) {
	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);

	len = sprintf(page,"\n\n"
		      " cell processor:\n"
		      "   heartbeat state:\t\t");
	
	if (hb >> 16 != 0xDEAD)
	    len += sprintf(page + len, "0x%08x\n", hb);
	else
	    len += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);

	return len;
    }

    if (!left--) {
	static const char* media_name[] = {
	    "unshielded twisted pair",
	    "multimode optical fiber ST",
	    "multimode optical fiber SC",
	    "single-mode optical fiber ST",
	    "single-mode optical fiber SC",
	    "unknown"
	};

	static const char* oc3_mode[] = {
	    "normal operation",
	    "diagnostic loopback",
	    "line loopback",
	    "unknown"
	};

	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
	u32 oc3_index;

	if (media_index > 4)
		media_index = 5;
	
	switch (fore200e->loop_mode) {
	    case ATM_LM_NONE:    oc3_index = 0;
		                 break;
	    case ATM_LM_LOC_PHY: oc3_index = 1;
		                 break;
	    case ATM_LM_RMT_PHY: oc3_index = 2;
		                 break;
	    default:             oc3_index = 3;
	}

	return sprintf(page,
		       "   firmware release:\t\t%d.%d.%d\n"
		       "   monitor release:\t\t%d.%d\n"
		       "   media type:\t\t\t%s\n"
		       "   OC-3 revision:\t\t0x%x\n"
                       "   OC-3 mode:\t\t\t%s",
		       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,
		       mon960_release >> 16, mon960_release << 16 >> 16,
		       media_name[ media_index ],
		       oc3_revision,
		       oc3_mode[ oc3_index ]);
    }

    if (!left--) {
	struct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;

	return sprintf(page,
		       "\n\n"
		       " monitor:\n"
		       "   version number:\t\t%d\n"
		       "   boot status word:\t\t0x%08x\n",
		       fore200e->bus->read(&cp_monitor->mon_version),
		       fore200e->bus->read(&cp_monitor->bstat));
    }

    if (!left--)
	return sprintf(page,
		       "\n"
		       " device statistics:\n"
		       "  4b5b:\n"
		       "     crc_header_errors:\t\t%10u\n"
		       "     framing_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->phy.crc_header_errors),
		       be32_to_cpu(fore200e->stats->phy.framing_errors));
    
    if (!left--)
	return sprintf(page, "\n"
		       "  OC-3:\n"
		       "     section_bip8_errors:\t%10u\n"
		       "     path_bip8_errors:\t\t%10u\n"
		       "     line_bip24_errors:\t\t%10u\n"
		       "     line_febe_errors:\t\t%10u\n"
		       "     path_febe_errors:\t\t%10u\n"
		       "     corr_hcs_errors:\t\t%10u\n"
		       "     ucorr_hcs_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),
		       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));

    if (!left--)
	return sprintf(page,"\n"
		       "   ATM:\t\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     vpi out of range:\t\t%10u\n"
		       "     vpi no conn:\t\t%10u\n"
		       "     vci out of range:\t\t%10u\n"
		       "     vci no conn:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->atm.cells_transmitted),
		       be32_to_cpu(fore200e->stats->atm.cells_received),
		       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),
		       be32_to_cpu(fore200e->stats->atm.vci_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vci_no_conn));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL0:\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     dropped:\t\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal0.cells_received),
		       be32_to_cpu(fore200e->stats->aal0.cells_dropped));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL3/4:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cells_received),
		       be32_to_cpu(fore200e->stats->aal34.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),
		       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL5:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       congestions:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cells_received),
		       be32_to_cpu(fore200e->stats->aal5.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal5.congestion_experienced),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AUX:\t\t       allocation failures\n"
		       "     small b1:\t\t\t%10u\n"
		       "     large b1:\t\t\t%10u\n"
		       "     small b2:\t\t\t%10u\n"
		       "     large b2:\t\t\t%10u\n"
		       "     RX PDUs:\t\t\t%10u\n"
		       "     TX PDUs:\t\t\t%10lu\n",
		       be32_to_cpu(fore200e->stats->aux.small_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.small_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),
		       fore200e->tx_sat);
    
    if (!left--)
	return sprintf(page,"\n"
		       " receive carrier:\t\t\t%s\n",
		       fore200e->stats->aux.receive_carrier ? "ON" : "OFF!");
    
    if (!left--) {
        return sprintf(page,"\n"
		       " VCCs:\n  address   VPI VCI   AAL "
		       "TX PDUs   TX min/max size  RX PDUs   RX min/max size\n");
    }

    for (i = 0; i < NBR_CONNECT; i++) {

	vcc = fore200e->vc_map[i].vcc;

	if (vcc == NULL)
	    continue;

	spin_lock_irqsave(&fore200e->q_lock, flags);

	if (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {

	    fore200e_vcc = FORE200E_VCC(vcc);
	    ASSERT(fore200e_vcc);

	    len = sprintf(page,
			  "  %pK  %03d %05d %1d   %09lu %05d/%05d      %09lu %05d/%05d\n",
			  vcc,
			  vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),
			  fore200e_vcc->tx_pdu,
			  fore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,
			  fore200e_vcc->tx_max_pdu,
			  fore200e_vcc->rx_pdu,
			  fore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,
			  fore200e_vcc->rx_max_pdu);

	    spin_unlock_irqrestore(&fore200e->q_lock, flags);
	    return len;
	}

	spin_unlock_irqrestore(&fore200e->q_lock, flags);
    }
    
    return 0;
}

module_init(fore200e_module_init);
module_exit(fore200e_module_cleanup);


static const struct atmdev_ops fore200e_ops = {
	.open       = fore200e_open,
	.close      = fore200e_close,
	.ioctl      = fore200e_ioctl,
	.send       = fore200e_send,
	.change_qos = fore200e_change_qos,
	.proc_read  = fore200e_proc_read,
	.owner      = THIS_MODULE
};

MODULE_LICENSE("GPL");
#ifdef CONFIG_PCI
#ifdef __LITTLE_ENDIAN__
MODULE_FIRMWARE("pca200e.bin");
#else
MODULE_FIRMWARE("pca200e_ecd.bin2");
#endif
#endif /* CONFIG_PCI */
#ifdef CONFIG_SBUS
MODULE_FIRMWARE("sba200e_ecd.bin2");
#endif
static void fore200e_param_bs_queue(struct fore200e *fore200e,
				    enum buffer_scheme scheme,
				    enum buffer_magn magn, int queue_length,
				    int pool_size, int supply_blksize)
{
    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];

    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
}


static int fore200e_initialize(struct fore200e *fore200e)
{
    struct cp_queues __iomem * cpq;
    int               ok, scheme, magn;

    DPRINTK(2, "device %s being initialized\n", fore200e->name);

    mutex_init(&fore200e->rate_mtx);
    spin_lock_init(&fore200e->q_lock);

    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;

    /* enable cp to host interrupts */
    fore200e->bus->write(1, &cpq->imask);

    if (fore200e->bus->irq_enable)
	fore200e->bus->irq_enable(fore200e);
    
    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);

    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);

    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);

    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)
	for (magn = 0; magn < BUFFER_MAGN_NBR; magn++)
	    fore200e_param_bs_queue(fore200e, scheme, magn,
				    QUEUE_SIZE_BS, 
				    fore200e_rx_buf_nbr[ scheme ][ magn ],
				    RBD_BLK_SIZE);

    /* issue the initialize command */
    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);

    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);
    if (ok == 0) {
	printk(FORE200E "device %s initialization failed\n", fore200e->name);
	return -ENODEV;
    }

    printk(FORE200E "device %s initialized\n", fore200e->name);

    fore200e->state = FORE200E_STATE_INITIALIZE;
    return 0;
}


static void fore200e_monitor_putc(struct fore200e *fore200e, char c)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;

#if 0
    printk("%c", c);
#endif
    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
}


static int fore200e_monitor_getc(struct fore200e *fore200e)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;
    unsigned long      timeout = jiffies + msecs_to_jiffies(50);
    int                c;

    while (time_before(jiffies, timeout)) {

	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);

	if (c & FORE200E_CP_MONITOR_UART_AVAIL) {

	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
#if 0
	    printk("%c", c & 0xFF);
#endif
	    return c & 0xFF;
	}
    }

    return -1;
}


static void fore200e_monitor_puts(struct fore200e *fore200e, char *str)
{
    while (*str) {

	/* the i960 monitor doesn't accept any new character if it has something to say */
	while (fore200e_monitor_getc(fore200e) >= 0);
	
	fore200e_monitor_putc(fore200e, *str++);
    }

    while (fore200e_monitor_getc(fore200e) >= 0);
}

#ifdef __LITTLE_ENDIAN
#define FW_EXT ".bin"
#else
#define FW_EXT "_ecd.bin2"
#endif

static int fore200e_load_and_start_fw(struct fore200e *fore200e)
{
    const struct firmware *firmware;
    const struct fw_header *fw_header;
    const __le32 *fw_data;
    u32 fw_size;
    u32 __iomem *load_addr;
    char buf[48];
    int err;

    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {
	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
	return err;
    }

    fw_data = (const __le32 *)firmware->data;
    fw_size = firmware->size / sizeof(u32);
    fw_header = (const struct fw_header *)firmware->data;
    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);

    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",
	    fore200e->name, load_addr, fw_size);

    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {
	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
	goto release;
    }

    for (; fw_size--; fw_data++, load_addr++)
	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);

    DPRINTK(2, "device %s firmware being started\n", fore200e->name);

#if defined(__sparc_v9__)
    /* reported to be required by SBA cards on some sparc64 hosts */
    fore200e_spin(100);
#endif

    sprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));
    fore200e_monitor_puts(fore200e, buf);

    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {
	printk(FORE200E "device %s firmware didn't start\n", fore200e->name);
	goto release;
    }

    printk(FORE200E "device %s firmware started\n", fore200e->name);

    fore200e->state = FORE200E_STATE_START_FW;
    err = 0;

release:
    release_firmware(firmware);
    return err;
}


static int fore200e_register(struct fore200e *fore200e, struct device *parent)
{
    struct atm_dev* atm_dev;

    DPRINTK(2, "device %s being registered\n", fore200e->name);

    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
                               -1, NULL);
    if (atm_dev == NULL) {
	printk(FORE200E "unable to register device %s\n", fore200e->name);
	return -ENODEV;
    }

    atm_dev->dev_data = fore200e;
    fore200e->atm_dev = atm_dev;

    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;
    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;

    fore200e->available_cell_rate = ATM_OC3_PCR;

    fore200e->state = FORE200E_STATE_REGISTER;
    return 0;
}


static int fore200e_init(struct fore200e *fore200e, struct device *parent)
{
    if (fore200e_register(fore200e, parent) < 0)
	return -ENODEV;
    
    if (fore200e->bus->configure(fore200e) < 0)
	return -ENODEV;

    if (fore200e->bus->map(fore200e) < 0)
	return -ENODEV;

    if (fore200e_reset(fore200e, 1) < 0)
	return -ENODEV;

    if (fore200e_load_and_start_fw(fore200e) < 0)
	return -ENODEV;

    if (fore200e_initialize(fore200e) < 0)
	return -ENODEV;

    if (fore200e_init_cmd_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_tx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_rx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_bs_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_alloc_rx_buf(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_get_esi(fore200e) < 0)
	return -EIO;

    if (fore200e_irq_request(fore200e) < 0)
	return -EBUSY;

    fore200e_supply(fore200e);

    /* all done, board initialization is now complete */
    fore200e->state = FORE200E_STATE_COMPLETE;
    return 0;
}

#ifdef CONFIG_SBUS
static const struct of_device_id fore200e_sba_match[];
static int fore200e_sba_probe(struct platform_device *op)
{
	const struct of_device_id *match;
	struct fore200e *fore200e;
	static int index = 0;
	int err;

	match = of_match_device(fore200e_sba_match, &op->dev);
	if (!match)
		return -EINVAL;

	fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
	if (!fore200e)
		return -ENOMEM;

	fore200e->bus = &fore200e_sbus_ops;
	fore200e->dev = &op->dev;
	fore200e->irq = op->archdata.irqs[0];
	fore200e->phys_base = op->resource[0].start;

	sprintf(fore200e->name, "SBA-200E-%d", index);

	err = fore200e_init(fore200e, &op->dev);
	if (err < 0) {
		fore200e_shutdown(fore200e);
		kfree(fore200e);
		return err;
	}

	index++;
	dev_set_drvdata(&op->dev, fore200e);

	return 0;
}

static int fore200e_sba_remove(struct platform_device *op)
{
	struct fore200e *fore200e = dev_get_drvdata(&op->dev);

	fore200e_shutdown(fore200e);
	kfree(fore200e);

	return 0;
}

static const struct of_device_id fore200e_sba_match[] = {
	{
		.name = SBA200E_PROM_NAME,
	},
	{},
};
MODULE_DEVICE_TABLE(of, fore200e_sba_match);

static struct platform_driver fore200e_sba_driver = {
	.driver = {
		.name = "fore_200e",
		.of_match_table = fore200e_sba_match,
	},
	.probe		= fore200e_sba_probe,
	.remove		= fore200e_sba_remove,
};
#endif

#ifdef CONFIG_PCI
static int fore200e_pca_detect(struct pci_dev *pci_dev,
			       const struct pci_device_id *pci_ent)
{
    struct fore200e* fore200e;
    int err = 0;
    static int index = 0;

    if (pci_enable_device(pci_dev)) {
	err = -EINVAL;
	goto out;
    }

    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {
	err = -EINVAL;
	goto out;
    }
    
    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
    if (fore200e == NULL) {
	err = -ENOMEM;
	goto out_disable;
    }

    fore200e->bus       = &fore200e_pci_ops;
    fore200e->dev	= &pci_dev->dev;
    fore200e->irq       = pci_dev->irq;
    fore200e->phys_base = pci_resource_start(pci_dev, 0);

    sprintf(fore200e->name, "PCA-200E-%d", index - 1);

    pci_set_master(pci_dev);

    printk(FORE200E "device PCA-200E found at 0x%lx, IRQ %s\n",
	   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));

    sprintf(fore200e->name, "PCA-200E-%d", index);

    err = fore200e_init(fore200e, &pci_dev->dev);
    if (err < 0) {
	fore200e_shutdown(fore200e);
	goto out_free;
    }

    ++index;
    pci_set_drvdata(pci_dev, fore200e);

out:
    return err;

out_free:
    kfree(fore200e);
out_disable:
    pci_disable_device(pci_dev);
    goto out;
}


static void fore200e_pca_remove_one(struct pci_dev *pci_dev)
{
    struct fore200e *fore200e;

    fore200e = pci_get_drvdata(pci_dev);

    fore200e_shutdown(fore200e);
    kfree(fore200e);
    pci_disable_device(pci_dev);
}


static const struct pci_device_id fore200e_pca_tbl[] = {
    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);

static struct pci_driver fore200e_pca_driver = {
    .name =     "fore_200e",
    .probe =    fore200e_pca_detect,
    .remove =   fore200e_pca_remove_one,
    .id_table = fore200e_pca_tbl,
};
#endif

static int __init fore200e_module_init(void)
{
	int err = 0;

	printk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");

#ifdef CONFIG_SBUS
	err = platform_driver_register(&fore200e_sba_driver);
	if (err)
		return err;
#endif

#ifdef CONFIG_PCI
	err = pci_register_driver(&fore200e_pca_driver);
#endif

#ifdef CONFIG_SBUS
	if (err)
		platform_driver_unregister(&fore200e_sba_driver);
#endif

	return err;
}

static void __exit fore200e_module_cleanup(void)
{
#ifdef CONFIG_PCI
	pci_unregister_driver(&fore200e_pca_driver);
#endif
#ifdef CONFIG_SBUS
	platform_driver_unregister(&fore200e_sba_driver);
#endif
}

static int
fore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)
{
    struct fore200e*     fore200e  = FORE200E_DEV(dev);
    struct fore200e_vcc* fore200e_vcc;
    struct atm_vcc*      vcc;
    int                  i, len, left = *pos;
    unsigned long        flags;

    if (!left--) {

	if (fore200e_getstats(fore200e) < 0)
	    return -EIO;

	len = sprintf(page,"\n"
		       " device:\n"
		       "   internal name:\t\t%s\n", fore200e->name);

	/* print bus-specific information */
	if (fore200e->bus->proc_read)
	    len += fore200e->bus->proc_read(fore200e, page + len);
	
	len += sprintf(page + len,
		"   interrupt line:\t\t%s\n"
		"   physical base address:\t0x%p\n"
		"   virtual base address:\t0x%p\n"
		"   factory address (ESI):\t%pM\n"
		"   board serial number:\t\t%d\n\n",
		fore200e_irq_itoa(fore200e->irq),
		(void*)fore200e->phys_base,
		fore200e->virt_base,
		fore200e->esi,
		fore200e->esi[4] * 256 + fore200e->esi[5]);

	return len;
    }

    if (!left--)
	return sprintf(page,
		       "   free small bufs, scheme 1:\t%d\n"
		       "   free large bufs, scheme 1:\t%d\n"
		       "   free small bufs, scheme 2:\t%d\n"
		       "   free large bufs, scheme 2:\t%d\n",
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);

    if (!left--) {
	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);

	len = sprintf(page,"\n\n"
		      " cell processor:\n"
		      "   heartbeat state:\t\t");
	
	if (hb >> 16 != 0xDEAD)
	    len += sprintf(page + len, "0x%08x\n", hb);
	else
	    len += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);

	return len;
    }

    if (!left--) {
	static const char* media_name[] = {
	    "unshielded twisted pair",
	    "multimode optical fiber ST",
	    "multimode optical fiber SC",
	    "single-mode optical fiber ST",
	    "single-mode optical fiber SC",
	    "unknown"
	};

	static const char* oc3_mode[] = {
	    "normal operation",
	    "diagnostic loopback",
	    "line loopback",
	    "unknown"
	};

	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
	u32 oc3_index;

	if (media_index > 4)
		media_index = 5;
	
	switch (fore200e->loop_mode) {
	    case ATM_LM_NONE:    oc3_index = 0;
		                 break;
	    case ATM_LM_LOC_PHY: oc3_index = 1;
		                 break;
	    case ATM_LM_RMT_PHY: oc3_index = 2;
		                 break;
	    default:             oc3_index = 3;
	}

	return sprintf(page,
		       "   firmware release:\t\t%d.%d.%d\n"
		       "   monitor release:\t\t%d.%d\n"
		       "   media type:\t\t\t%s\n"
		       "   OC-3 revision:\t\t0x%x\n"
                       "   OC-3 mode:\t\t\t%s",
		       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,
		       mon960_release >> 16, mon960_release << 16 >> 16,
		       media_name[ media_index ],
		       oc3_revision,
		       oc3_mode[ oc3_index ]);
    }

    if (!left--) {
	struct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;

	return sprintf(page,
		       "\n\n"
		       " monitor:\n"
		       "   version number:\t\t%d\n"
		       "   boot status word:\t\t0x%08x\n",
		       fore200e->bus->read(&cp_monitor->mon_version),
		       fore200e->bus->read(&cp_monitor->bstat));
    }

    if (!left--)
	return sprintf(page,
		       "\n"
		       " device statistics:\n"
		       "  4b5b:\n"
		       "     crc_header_errors:\t\t%10u\n"
		       "     framing_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->phy.crc_header_errors),
		       be32_to_cpu(fore200e->stats->phy.framing_errors));
    
    if (!left--)
	return sprintf(page, "\n"
		       "  OC-3:\n"
		       "     section_bip8_errors:\t%10u\n"
		       "     path_bip8_errors:\t\t%10u\n"
		       "     line_bip24_errors:\t\t%10u\n"
		       "     line_febe_errors:\t\t%10u\n"
		       "     path_febe_errors:\t\t%10u\n"
		       "     corr_hcs_errors:\t\t%10u\n"
		       "     ucorr_hcs_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),
		       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));

    if (!left--)
	return sprintf(page,"\n"
		       "   ATM:\t\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     vpi out of range:\t\t%10u\n"
		       "     vpi no conn:\t\t%10u\n"
		       "     vci out of range:\t\t%10u\n"
		       "     vci no conn:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->atm.cells_transmitted),
		       be32_to_cpu(fore200e->stats->atm.cells_received),
		       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),
		       be32_to_cpu(fore200e->stats->atm.vci_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vci_no_conn));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL0:\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     dropped:\t\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal0.cells_received),
		       be32_to_cpu(fore200e->stats->aal0.cells_dropped));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL3/4:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cells_received),
		       be32_to_cpu(fore200e->stats->aal34.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),
		       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL5:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       congestions:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cells_received),
		       be32_to_cpu(fore200e->stats->aal5.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal5.congestion_experienced),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AUX:\t\t       allocation failures\n"
		       "     small b1:\t\t\t%10u\n"
		       "     large b1:\t\t\t%10u\n"
		       "     small b2:\t\t\t%10u\n"
		       "     large b2:\t\t\t%10u\n"
		       "     RX PDUs:\t\t\t%10u\n"
		       "     TX PDUs:\t\t\t%10lu\n",
		       be32_to_cpu(fore200e->stats->aux.small_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.small_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),
		       fore200e->tx_sat);
    
    if (!left--)
	return sprintf(page,"\n"
		       " receive carrier:\t\t\t%s\n",
		       fore200e->stats->aux.receive_carrier ? "ON" : "OFF!");
    
    if (!left--) {
        return sprintf(page,"\n"
		       " VCCs:\n  address   VPI VCI   AAL "
		       "TX PDUs   TX min/max size  RX PDUs   RX min/max size\n");
    }

    for (i = 0; i < NBR_CONNECT; i++) {

	vcc = fore200e->vc_map[i].vcc;

	if (vcc == NULL)
	    continue;

	spin_lock_irqsave(&fore200e->q_lock, flags);

	if (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {

	    fore200e_vcc = FORE200E_VCC(vcc);
	    ASSERT(fore200e_vcc);

	    len = sprintf(page,
			  "  %pK  %03d %05d %1d   %09lu %05d/%05d      %09lu %05d/%05d\n",
			  vcc,
			  vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),
			  fore200e_vcc->tx_pdu,
			  fore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,
			  fore200e_vcc->tx_max_pdu,
			  fore200e_vcc->rx_pdu,
			  fore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,
			  fore200e_vcc->rx_max_pdu);

	    spin_unlock_irqrestore(&fore200e->q_lock, flags);
	    return len;
	}

	spin_unlock_irqrestore(&fore200e->q_lock, flags);
    }
    
    return 0;
}

module_init(fore200e_module_init);
module_exit(fore200e_module_cleanup);


static const struct atmdev_ops fore200e_ops = {
	.open       = fore200e_open,
	.close      = fore200e_close,
	.ioctl      = fore200e_ioctl,
	.send       = fore200e_send,
	.change_qos = fore200e_change_qos,
	.proc_read  = fore200e_proc_read,
	.owner      = THIS_MODULE
};

MODULE_LICENSE("GPL");
#ifdef CONFIG_PCI
#ifdef __LITTLE_ENDIAN__
MODULE_FIRMWARE("pca200e.bin");
#else
MODULE_FIRMWARE("pca200e_ecd.bin2");
#endif
#endif /* CONFIG_PCI */
#ifdef CONFIG_SBUS
MODULE_FIRMWARE("sba200e_ecd.bin2");
#endif
static void fore200e_param_bs_queue(struct fore200e *fore200e,
				    enum buffer_scheme scheme,
				    enum buffer_magn magn, int queue_length,
				    int pool_size, int supply_blksize)
{
    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];

    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
}


static int fore200e_initialize(struct fore200e *fore200e)
{
    struct cp_queues __iomem * cpq;
    int               ok, scheme, magn;

    DPRINTK(2, "device %s being initialized\n", fore200e->name);

    mutex_init(&fore200e->rate_mtx);
    spin_lock_init(&fore200e->q_lock);

    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;

    /* enable cp to host interrupts */
    fore200e->bus->write(1, &cpq->imask);

    if (fore200e->bus->irq_enable)
	fore200e->bus->irq_enable(fore200e);
    
    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);

    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);

    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);

    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)
	for (magn = 0; magn < BUFFER_MAGN_NBR; magn++)
	    fore200e_param_bs_queue(fore200e, scheme, magn,
				    QUEUE_SIZE_BS, 
				    fore200e_rx_buf_nbr[ scheme ][ magn ],
				    RBD_BLK_SIZE);

    /* issue the initialize command */
    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);

    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);
    if (ok == 0) {
	printk(FORE200E "device %s initialization failed\n", fore200e->name);
	return -ENODEV;
    }

    printk(FORE200E "device %s initialized\n", fore200e->name);

    fore200e->state = FORE200E_STATE_INITIALIZE;
    return 0;
}


static void fore200e_monitor_putc(struct fore200e *fore200e, char c)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;

#if 0
    printk("%c", c);
#endif
    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
}


static int fore200e_monitor_getc(struct fore200e *fore200e)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;
    unsigned long      timeout = jiffies + msecs_to_jiffies(50);
    int                c;

    while (time_before(jiffies, timeout)) {

	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);

	if (c & FORE200E_CP_MONITOR_UART_AVAIL) {

	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
#if 0
	    printk("%c", c & 0xFF);
#endif
	    return c & 0xFF;
	}
    }

    return -1;
}


static void fore200e_monitor_puts(struct fore200e *fore200e, char *str)
{
    while (*str) {

	/* the i960 monitor doesn't accept any new character if it has something to say */
	while (fore200e_monitor_getc(fore200e) >= 0);
	
	fore200e_monitor_putc(fore200e, *str++);
    }

    while (fore200e_monitor_getc(fore200e) >= 0);
}

#ifdef __LITTLE_ENDIAN
#define FW_EXT ".bin"
#else
#define FW_EXT "_ecd.bin2"
#endif

static int fore200e_load_and_start_fw(struct fore200e *fore200e)
{
    const struct firmware *firmware;
    const struct fw_header *fw_header;
    const __le32 *fw_data;
    u32 fw_size;
    u32 __iomem *load_addr;
    char buf[48];
    int err;

    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {
	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
	return err;
    }

    fw_data = (const __le32 *)firmware->data;
    fw_size = firmware->size / sizeof(u32);
    fw_header = (const struct fw_header *)firmware->data;
    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);

    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",
	    fore200e->name, load_addr, fw_size);

    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {
	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
	goto release;
    }

    for (; fw_size--; fw_data++, load_addr++)
	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);

    DPRINTK(2, "device %s firmware being started\n", fore200e->name);

#if defined(__sparc_v9__)
    /* reported to be required by SBA cards on some sparc64 hosts */
    fore200e_spin(100);
#endif

    sprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));
    fore200e_monitor_puts(fore200e, buf);

    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {
	printk(FORE200E "device %s firmware didn't start\n", fore200e->name);
	goto release;
    }

    printk(FORE200E "device %s firmware started\n", fore200e->name);

    fore200e->state = FORE200E_STATE_START_FW;
    err = 0;

release:
    release_firmware(firmware);
    return err;
}


static int fore200e_register(struct fore200e *fore200e, struct device *parent)
{
    struct atm_dev* atm_dev;

    DPRINTK(2, "device %s being registered\n", fore200e->name);

    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
                               -1, NULL);
    if (atm_dev == NULL) {
	printk(FORE200E "unable to register device %s\n", fore200e->name);
	return -ENODEV;
    }

    atm_dev->dev_data = fore200e;
    fore200e->atm_dev = atm_dev;

    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;
    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;

    fore200e->available_cell_rate = ATM_OC3_PCR;

    fore200e->state = FORE200E_STATE_REGISTER;
    return 0;
}


static int fore200e_init(struct fore200e *fore200e, struct device *parent)
{
    if (fore200e_register(fore200e, parent) < 0)
	return -ENODEV;
    
    if (fore200e->bus->configure(fore200e) < 0)
	return -ENODEV;

    if (fore200e->bus->map(fore200e) < 0)
	return -ENODEV;

    if (fore200e_reset(fore200e, 1) < 0)
	return -ENODEV;

    if (fore200e_load_and_start_fw(fore200e) < 0)
	return -ENODEV;

    if (fore200e_initialize(fore200e) < 0)
	return -ENODEV;

    if (fore200e_init_cmd_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_tx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_rx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_bs_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_alloc_rx_buf(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_get_esi(fore200e) < 0)
	return -EIO;

    if (fore200e_irq_request(fore200e) < 0)
	return -EBUSY;

    fore200e_supply(fore200e);

    /* all done, board initialization is now complete */
    fore200e->state = FORE200E_STATE_COMPLETE;
    return 0;
}

#ifdef CONFIG_SBUS
static const struct of_device_id fore200e_sba_match[];
static int fore200e_sba_probe(struct platform_device *op)
{
	const struct of_device_id *match;
	struct fore200e *fore200e;
	static int index = 0;
	int err;

	match = of_match_device(fore200e_sba_match, &op->dev);
	if (!match)
		return -EINVAL;

	fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
	if (!fore200e)
		return -ENOMEM;

	fore200e->bus = &fore200e_sbus_ops;
	fore200e->dev = &op->dev;
	fore200e->irq = op->archdata.irqs[0];
	fore200e->phys_base = op->resource[0].start;

	sprintf(fore200e->name, "SBA-200E-%d", index);

	err = fore200e_init(fore200e, &op->dev);
	if (err < 0) {
		fore200e_shutdown(fore200e);
		kfree(fore200e);
		return err;
	}

	index++;
	dev_set_drvdata(&op->dev, fore200e);

	return 0;
}

static int fore200e_sba_remove(struct platform_device *op)
{
	struct fore200e *fore200e = dev_get_drvdata(&op->dev);

	fore200e_shutdown(fore200e);
	kfree(fore200e);

	return 0;
}

static const struct of_device_id fore200e_sba_match[] = {
	{
		.name = SBA200E_PROM_NAME,
	},
	{},
};
MODULE_DEVICE_TABLE(of, fore200e_sba_match);

static struct platform_driver fore200e_sba_driver = {
	.driver = {
		.name = "fore_200e",
		.of_match_table = fore200e_sba_match,
	},
	.probe		= fore200e_sba_probe,
	.remove		= fore200e_sba_remove,
};
#endif

#ifdef CONFIG_PCI
static int fore200e_pca_detect(struct pci_dev *pci_dev,
			       const struct pci_device_id *pci_ent)
{
    struct fore200e* fore200e;
    int err = 0;
    static int index = 0;

    if (pci_enable_device(pci_dev)) {
	err = -EINVAL;
	goto out;
    }

    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {
	err = -EINVAL;
	goto out;
    }
    
    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
    if (fore200e == NULL) {
	err = -ENOMEM;
	goto out_disable;
    }

    fore200e->bus       = &fore200e_pci_ops;
    fore200e->dev	= &pci_dev->dev;
    fore200e->irq       = pci_dev->irq;
    fore200e->phys_base = pci_resource_start(pci_dev, 0);

    sprintf(fore200e->name, "PCA-200E-%d", index - 1);

    pci_set_master(pci_dev);

    printk(FORE200E "device PCA-200E found at 0x%lx, IRQ %s\n",
	   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));

    sprintf(fore200e->name, "PCA-200E-%d", index);

    err = fore200e_init(fore200e, &pci_dev->dev);
    if (err < 0) {
	fore200e_shutdown(fore200e);
	goto out_free;
    }

    ++index;
    pci_set_drvdata(pci_dev, fore200e);

out:
    return err;

out_free:
    kfree(fore200e);
out_disable:
    pci_disable_device(pci_dev);
    goto out;
}


static void fore200e_pca_remove_one(struct pci_dev *pci_dev)
{
    struct fore200e *fore200e;

    fore200e = pci_get_drvdata(pci_dev);

    fore200e_shutdown(fore200e);
    kfree(fore200e);
    pci_disable_device(pci_dev);
}


static const struct pci_device_id fore200e_pca_tbl[] = {
    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);

static struct pci_driver fore200e_pca_driver = {
    .name =     "fore_200e",
    .probe =    fore200e_pca_detect,
    .remove =   fore200e_pca_remove_one,
    .id_table = fore200e_pca_tbl,
};
#endif

static int __init fore200e_module_init(void)
{
	int err = 0;

	printk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");

#ifdef CONFIG_SBUS
	err = platform_driver_register(&fore200e_sba_driver);
	if (err)
		return err;
#endif

#ifdef CONFIG_PCI
	err = pci_register_driver(&fore200e_pca_driver);
#endif

#ifdef CONFIG_SBUS
	if (err)
		platform_driver_unregister(&fore200e_sba_driver);
#endif

	return err;
}

static void __exit fore200e_module_cleanup(void)
{
#ifdef CONFIG_PCI
	pci_unregister_driver(&fore200e_pca_driver);
#endif
#ifdef CONFIG_SBUS
	platform_driver_unregister(&fore200e_sba_driver);
#endif
}

static int
fore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)
{
    struct fore200e*     fore200e  = FORE200E_DEV(dev);
    struct fore200e_vcc* fore200e_vcc;
    struct atm_vcc*      vcc;
    int                  i, len, left = *pos;
    unsigned long        flags;

    if (!left--) {

	if (fore200e_getstats(fore200e) < 0)
	    return -EIO;

	len = sprintf(page,"\n"
		       " device:\n"
		       "   internal name:\t\t%s\n", fore200e->name);

	/* print bus-specific information */
	if (fore200e->bus->proc_read)
	    len += fore200e->bus->proc_read(fore200e, page + len);
	
	len += sprintf(page + len,
		"   interrupt line:\t\t%s\n"
		"   physical base address:\t0x%p\n"
		"   virtual base address:\t0x%p\n"
		"   factory address (ESI):\t%pM\n"
		"   board serial number:\t\t%d\n\n",
		fore200e_irq_itoa(fore200e->irq),
		(void*)fore200e->phys_base,
		fore200e->virt_base,
		fore200e->esi,
		fore200e->esi[4] * 256 + fore200e->esi[5]);

	return len;
    }

    if (!left--)
	return sprintf(page,
		       "   free small bufs, scheme 1:\t%d\n"
		       "   free large bufs, scheme 1:\t%d\n"
		       "   free small bufs, scheme 2:\t%d\n"
		       "   free large bufs, scheme 2:\t%d\n",
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);

    if (!left--) {
	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);

	len = sprintf(page,"\n\n"
		      " cell processor:\n"
		      "   heartbeat state:\t\t");
	
	if (hb >> 16 != 0xDEAD)
	    len += sprintf(page + len, "0x%08x\n", hb);
	else
	    len += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);

	return len;
    }

    if (!left--) {
	static const char* media_name[] = {
	    "unshielded twisted pair",
	    "multimode optical fiber ST",
	    "multimode optical fiber SC",
	    "single-mode optical fiber ST",
	    "single-mode optical fiber SC",
	    "unknown"
	};

	static const char* oc3_mode[] = {
	    "normal operation",
	    "diagnostic loopback",
	    "line loopback",
	    "unknown"
	};

	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
	u32 oc3_index;

	if (media_index > 4)
		media_index = 5;
	
	switch (fore200e->loop_mode) {
	    case ATM_LM_NONE:    oc3_index = 0;
		                 break;
	    case ATM_LM_LOC_PHY: oc3_index = 1;
		                 break;
	    case ATM_LM_RMT_PHY: oc3_index = 2;
		                 break;
	    default:             oc3_index = 3;
	}

	return sprintf(page,
		       "   firmware release:\t\t%d.%d.%d\n"
		       "   monitor release:\t\t%d.%d\n"
		       "   media type:\t\t\t%s\n"
		       "   OC-3 revision:\t\t0x%x\n"
                       "   OC-3 mode:\t\t\t%s",
		       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,
		       mon960_release >> 16, mon960_release << 16 >> 16,
		       media_name[ media_index ],
		       oc3_revision,
		       oc3_mode[ oc3_index ]);
    }

    if (!left--) {
	struct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;

	return sprintf(page,
		       "\n\n"
		       " monitor:\n"
		       "   version number:\t\t%d\n"
		       "   boot status word:\t\t0x%08x\n",
		       fore200e->bus->read(&cp_monitor->mon_version),
		       fore200e->bus->read(&cp_monitor->bstat));
    }

    if (!left--)
	return sprintf(page,
		       "\n"
		       " device statistics:\n"
		       "  4b5b:\n"
		       "     crc_header_errors:\t\t%10u\n"
		       "     framing_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->phy.crc_header_errors),
		       be32_to_cpu(fore200e->stats->phy.framing_errors));
    
    if (!left--)
	return sprintf(page, "\n"
		       "  OC-3:\n"
		       "     section_bip8_errors:\t%10u\n"
		       "     path_bip8_errors:\t\t%10u\n"
		       "     line_bip24_errors:\t\t%10u\n"
		       "     line_febe_errors:\t\t%10u\n"
		       "     path_febe_errors:\t\t%10u\n"
		       "     corr_hcs_errors:\t\t%10u\n"
		       "     ucorr_hcs_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),
		       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));

    if (!left--)
	return sprintf(page,"\n"
		       "   ATM:\t\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     vpi out of range:\t\t%10u\n"
		       "     vpi no conn:\t\t%10u\n"
		       "     vci out of range:\t\t%10u\n"
		       "     vci no conn:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->atm.cells_transmitted),
		       be32_to_cpu(fore200e->stats->atm.cells_received),
		       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),
		       be32_to_cpu(fore200e->stats->atm.vci_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vci_no_conn));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL0:\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     dropped:\t\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal0.cells_received),
		       be32_to_cpu(fore200e->stats->aal0.cells_dropped));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL3/4:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cells_received),
		       be32_to_cpu(fore200e->stats->aal34.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),
		       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL5:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       congestions:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cells_received),
		       be32_to_cpu(fore200e->stats->aal5.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal5.congestion_experienced),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_crc_errors),
		       be32_to_cpu(fore200e->stats->aal5.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AUX:\t\t       allocation failures\n"
		       "     small b1:\t\t\t%10u\n"
		       "     large b1:\t\t\t%10u\n"
		       "     small b2:\t\t\t%10u\n"
		       "     large b2:\t\t\t%10u\n"
		       "     RX PDUs:\t\t\t%10u\n"
		       "     TX PDUs:\t\t\t%10lu\n",
		       be32_to_cpu(fore200e->stats->aux.small_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b1_failed),
		       be32_to_cpu(fore200e->stats->aux.small_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.large_b2_failed),
		       be32_to_cpu(fore200e->stats->aux.rpd_alloc_failed),
		       fore200e->tx_sat);
    
    if (!left--)
	return sprintf(page,"\n"
		       " receive carrier:\t\t\t%s\n",
		       fore200e->stats->aux.receive_carrier ? "ON" : "OFF!");
    
    if (!left--) {
        return sprintf(page,"\n"
		       " VCCs:\n  address   VPI VCI   AAL "
		       "TX PDUs   TX min/max size  RX PDUs   RX min/max size\n");
    }

    for (i = 0; i < NBR_CONNECT; i++) {

	vcc = fore200e->vc_map[i].vcc;

	if (vcc == NULL)
	    continue;

	spin_lock_irqsave(&fore200e->q_lock, flags);

	if (vcc && test_bit(ATM_VF_READY, &vcc->flags) && !left--) {

	    fore200e_vcc = FORE200E_VCC(vcc);
	    ASSERT(fore200e_vcc);

	    len = sprintf(page,
			  "  %pK  %03d %05d %1d   %09lu %05d/%05d      %09lu %05d/%05d\n",
			  vcc,
			  vcc->vpi, vcc->vci, fore200e_atm2fore_aal(vcc->qos.aal),
			  fore200e_vcc->tx_pdu,
			  fore200e_vcc->tx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->tx_min_pdu,
			  fore200e_vcc->tx_max_pdu,
			  fore200e_vcc->rx_pdu,
			  fore200e_vcc->rx_min_pdu > 0xFFFF ? 0 : fore200e_vcc->rx_min_pdu,
			  fore200e_vcc->rx_max_pdu);

	    spin_unlock_irqrestore(&fore200e->q_lock, flags);
	    return len;
	}

	spin_unlock_irqrestore(&fore200e->q_lock, flags);
    }
    
    return 0;
}

module_init(fore200e_module_init);
module_exit(fore200e_module_cleanup);


static const struct atmdev_ops fore200e_ops = {
	.open       = fore200e_open,
	.close      = fore200e_close,
	.ioctl      = fore200e_ioctl,
	.send       = fore200e_send,
	.change_qos = fore200e_change_qos,
	.proc_read  = fore200e_proc_read,
	.owner      = THIS_MODULE
};

MODULE_LICENSE("GPL");
#ifdef CONFIG_PCI
#ifdef __LITTLE_ENDIAN__
MODULE_FIRMWARE("pca200e.bin");
#else
MODULE_FIRMWARE("pca200e_ecd.bin2");
#endif
#endif /* CONFIG_PCI */
#ifdef CONFIG_SBUS
MODULE_FIRMWARE("sba200e_ecd.bin2");
#endif
static void fore200e_param_bs_queue(struct fore200e *fore200e,
				    enum buffer_scheme scheme,
				    enum buffer_magn magn, int queue_length,
				    int pool_size, int supply_blksize)
{
    struct bs_spec __iomem * bs_spec = &fore200e->cp_queues->init.bs_spec[ scheme ][ magn ];

    fore200e->bus->write(queue_length,                           &bs_spec->queue_length);
    fore200e->bus->write(fore200e_rx_buf_size[ scheme ][ magn ], &bs_spec->buffer_size);
    fore200e->bus->write(pool_size,                              &bs_spec->pool_size);
    fore200e->bus->write(supply_blksize,                         &bs_spec->supply_blksize);
}


static int fore200e_initialize(struct fore200e *fore200e)
{
    struct cp_queues __iomem * cpq;
    int               ok, scheme, magn;

    DPRINTK(2, "device %s being initialized\n", fore200e->name);

    mutex_init(&fore200e->rate_mtx);
    spin_lock_init(&fore200e->q_lock);

    cpq = fore200e->cp_queues = fore200e->virt_base + FORE200E_CP_QUEUES_OFFSET;

    /* enable cp to host interrupts */
    fore200e->bus->write(1, &cpq->imask);

    if (fore200e->bus->irq_enable)
	fore200e->bus->irq_enable(fore200e);
    
    fore200e->bus->write(NBR_CONNECT, &cpq->init.num_connect);

    fore200e->bus->write(QUEUE_SIZE_CMD, &cpq->init.cmd_queue_len);
    fore200e->bus->write(QUEUE_SIZE_RX,  &cpq->init.rx_queue_len);
    fore200e->bus->write(QUEUE_SIZE_TX,  &cpq->init.tx_queue_len);

    fore200e->bus->write(RSD_EXTENSION,  &cpq->init.rsd_extension);
    fore200e->bus->write(TSD_EXTENSION,  &cpq->init.tsd_extension);

    for (scheme = 0; scheme < BUFFER_SCHEME_NBR; scheme++)
	for (magn = 0; magn < BUFFER_MAGN_NBR; magn++)
	    fore200e_param_bs_queue(fore200e, scheme, magn,
				    QUEUE_SIZE_BS, 
				    fore200e_rx_buf_nbr[ scheme ][ magn ],
				    RBD_BLK_SIZE);

    /* issue the initialize command */
    fore200e->bus->write(STATUS_PENDING,    &cpq->init.status);
    fore200e->bus->write(OPCODE_INITIALIZE, &cpq->init.opcode);

    ok = fore200e_io_poll(fore200e, &cpq->init.status, STATUS_COMPLETE, 3000);
    if (ok == 0) {
	printk(FORE200E "device %s initialization failed\n", fore200e->name);
	return -ENODEV;
    }

    printk(FORE200E "device %s initialized\n", fore200e->name);

    fore200e->state = FORE200E_STATE_INITIALIZE;
    return 0;
}


static void fore200e_monitor_putc(struct fore200e *fore200e, char c)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;

#if 0
    printk("%c", c);
#endif
    fore200e->bus->write(((u32) c) | FORE200E_CP_MONITOR_UART_AVAIL, &monitor->soft_uart.send);
}


static int fore200e_monitor_getc(struct fore200e *fore200e)
{
    struct cp_monitor __iomem * monitor = fore200e->cp_monitor;
    unsigned long      timeout = jiffies + msecs_to_jiffies(50);
    int                c;

    while (time_before(jiffies, timeout)) {

	c = (int) fore200e->bus->read(&monitor->soft_uart.recv);

	if (c & FORE200E_CP_MONITOR_UART_AVAIL) {

	    fore200e->bus->write(FORE200E_CP_MONITOR_UART_FREE, &monitor->soft_uart.recv);
#if 0
	    printk("%c", c & 0xFF);
#endif
	    return c & 0xFF;
	}
    }

    return -1;
}


static void fore200e_monitor_puts(struct fore200e *fore200e, char *str)
{
    while (*str) {

	/* the i960 monitor doesn't accept any new character if it has something to say */
	while (fore200e_monitor_getc(fore200e) >= 0);
	
	fore200e_monitor_putc(fore200e, *str++);
    }

    while (fore200e_monitor_getc(fore200e) >= 0);
}

#ifdef __LITTLE_ENDIAN
#define FW_EXT ".bin"
#else
#define FW_EXT "_ecd.bin2"
#endif

static int fore200e_load_and_start_fw(struct fore200e *fore200e)
{
    const struct firmware *firmware;
    const struct fw_header *fw_header;
    const __le32 *fw_data;
    u32 fw_size;
    u32 __iomem *load_addr;
    char buf[48];
    int err;

    sprintf(buf, "%s%s", fore200e->bus->proc_name, FW_EXT);
    if ((err = request_firmware(&firmware, buf, fore200e->dev)) < 0) {
	printk(FORE200E "problem loading firmware image %s\n", fore200e->bus->model_name);
	return err;
    }

    fw_data = (const __le32 *)firmware->data;
    fw_size = firmware->size / sizeof(u32);
    fw_header = (const struct fw_header *)firmware->data;
    load_addr = fore200e->virt_base + le32_to_cpu(fw_header->load_offset);

    DPRINTK(2, "device %s firmware being loaded at 0x%p (%d words)\n",
	    fore200e->name, load_addr, fw_size);

    if (le32_to_cpu(fw_header->magic) != FW_HEADER_MAGIC) {
	printk(FORE200E "corrupted %s firmware image\n", fore200e->bus->model_name);
	goto release;
    }

    for (; fw_size--; fw_data++, load_addr++)
	fore200e->bus->write(le32_to_cpu(*fw_data), load_addr);

    DPRINTK(2, "device %s firmware being started\n", fore200e->name);

#if defined(__sparc_v9__)
    /* reported to be required by SBA cards on some sparc64 hosts */
    fore200e_spin(100);
#endif

    sprintf(buf, "\rgo %x\r", le32_to_cpu(fw_header->start_offset));
    fore200e_monitor_puts(fore200e, buf);

    if (fore200e_io_poll(fore200e, &fore200e->cp_monitor->bstat, BSTAT_CP_RUNNING, 1000) == 0) {
	printk(FORE200E "device %s firmware didn't start\n", fore200e->name);
	goto release;
    }

    printk(FORE200E "device %s firmware started\n", fore200e->name);

    fore200e->state = FORE200E_STATE_START_FW;
    err = 0;

release:
    release_firmware(firmware);
    return err;
}


static int fore200e_register(struct fore200e *fore200e, struct device *parent)
{
    struct atm_dev* atm_dev;

    DPRINTK(2, "device %s being registered\n", fore200e->name);

    atm_dev = atm_dev_register(fore200e->bus->proc_name, parent, &fore200e_ops,
                               -1, NULL);
    if (atm_dev == NULL) {
	printk(FORE200E "unable to register device %s\n", fore200e->name);
	return -ENODEV;
    }

    atm_dev->dev_data = fore200e;
    fore200e->atm_dev = atm_dev;

    atm_dev->ci_range.vpi_bits = FORE200E_VPI_BITS;
    atm_dev->ci_range.vci_bits = FORE200E_VCI_BITS;

    fore200e->available_cell_rate = ATM_OC3_PCR;

    fore200e->state = FORE200E_STATE_REGISTER;
    return 0;
}


static int fore200e_init(struct fore200e *fore200e, struct device *parent)
{
    if (fore200e_register(fore200e, parent) < 0)
	return -ENODEV;
    
    if (fore200e->bus->configure(fore200e) < 0)
	return -ENODEV;

    if (fore200e->bus->map(fore200e) < 0)
	return -ENODEV;

    if (fore200e_reset(fore200e, 1) < 0)
	return -ENODEV;

    if (fore200e_load_and_start_fw(fore200e) < 0)
	return -ENODEV;

    if (fore200e_initialize(fore200e) < 0)
	return -ENODEV;

    if (fore200e_init_cmd_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_tx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_rx_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_init_bs_queue(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_alloc_rx_buf(fore200e) < 0)
	return -ENOMEM;

    if (fore200e_get_esi(fore200e) < 0)
	return -EIO;

    if (fore200e_irq_request(fore200e) < 0)
	return -EBUSY;

    fore200e_supply(fore200e);

    /* all done, board initialization is now complete */
    fore200e->state = FORE200E_STATE_COMPLETE;
    return 0;
}

#ifdef CONFIG_SBUS
static const struct of_device_id fore200e_sba_match[];
static int fore200e_sba_probe(struct platform_device *op)
{
	const struct of_device_id *match;
	struct fore200e *fore200e;
	static int index = 0;
	int err;

	match = of_match_device(fore200e_sba_match, &op->dev);
	if (!match)
		return -EINVAL;

	fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
	if (!fore200e)
		return -ENOMEM;

	fore200e->bus = &fore200e_sbus_ops;
	fore200e->dev = &op->dev;
	fore200e->irq = op->archdata.irqs[0];
	fore200e->phys_base = op->resource[0].start;

	sprintf(fore200e->name, "SBA-200E-%d", index);

	err = fore200e_init(fore200e, &op->dev);
	if (err < 0) {
		fore200e_shutdown(fore200e);
		kfree(fore200e);
		return err;
	}

	index++;
	dev_set_drvdata(&op->dev, fore200e);

	return 0;
}

static int fore200e_sba_remove(struct platform_device *op)
{
	struct fore200e *fore200e = dev_get_drvdata(&op->dev);

	fore200e_shutdown(fore200e);
	kfree(fore200e);

	return 0;
}

static const struct of_device_id fore200e_sba_match[] = {
	{
		.name = SBA200E_PROM_NAME,
	},
	{},
};
MODULE_DEVICE_TABLE(of, fore200e_sba_match);

static struct platform_driver fore200e_sba_driver = {
	.driver = {
		.name = "fore_200e",
		.of_match_table = fore200e_sba_match,
	},
	.probe		= fore200e_sba_probe,
	.remove		= fore200e_sba_remove,
};
#endif

#ifdef CONFIG_PCI
static int fore200e_pca_detect(struct pci_dev *pci_dev,
			       const struct pci_device_id *pci_ent)
{
    struct fore200e* fore200e;
    int err = 0;
    static int index = 0;

    if (pci_enable_device(pci_dev)) {
	err = -EINVAL;
	goto out;
    }

    if (dma_set_mask_and_coherent(&pci_dev->dev, DMA_BIT_MASK(32))) {
	err = -EINVAL;
	goto out;
    }
    
    fore200e = kzalloc(sizeof(struct fore200e), GFP_KERNEL);
    if (fore200e == NULL) {
	err = -ENOMEM;
	goto out_disable;
    }

    fore200e->bus       = &fore200e_pci_ops;
    fore200e->dev	= &pci_dev->dev;
    fore200e->irq       = pci_dev->irq;
    fore200e->phys_base = pci_resource_start(pci_dev, 0);

    sprintf(fore200e->name, "PCA-200E-%d", index - 1);

    pci_set_master(pci_dev);

    printk(FORE200E "device PCA-200E found at 0x%lx, IRQ %s\n",
	   fore200e->phys_base, fore200e_irq_itoa(fore200e->irq));

    sprintf(fore200e->name, "PCA-200E-%d", index);

    err = fore200e_init(fore200e, &pci_dev->dev);
    if (err < 0) {
	fore200e_shutdown(fore200e);
	goto out_free;
    }

    ++index;
    pci_set_drvdata(pci_dev, fore200e);

out:
    return err;

out_free:
    kfree(fore200e);
out_disable:
    pci_disable_device(pci_dev);
    goto out;
}


static void fore200e_pca_remove_one(struct pci_dev *pci_dev)
{
    struct fore200e *fore200e;

    fore200e = pci_get_drvdata(pci_dev);

    fore200e_shutdown(fore200e);
    kfree(fore200e);
    pci_disable_device(pci_dev);
}


static const struct pci_device_id fore200e_pca_tbl[] = {
    { PCI_VENDOR_ID_FORE, PCI_DEVICE_ID_FORE_PCA200E, PCI_ANY_ID, PCI_ANY_ID },
    { 0, }
};

MODULE_DEVICE_TABLE(pci, fore200e_pca_tbl);

static struct pci_driver fore200e_pca_driver = {
    .name =     "fore_200e",
    .probe =    fore200e_pca_detect,
    .remove =   fore200e_pca_remove_one,
    .id_table = fore200e_pca_tbl,
};
#endif

static int __init fore200e_module_init(void)
{
	int err = 0;

	printk(FORE200E "FORE Systems 200E-series ATM driver - version " FORE200E_VERSION "\n");

#ifdef CONFIG_SBUS
	err = platform_driver_register(&fore200e_sba_driver);
	if (err)
		return err;
#endif

#ifdef CONFIG_PCI
	err = pci_register_driver(&fore200e_pca_driver);
#endif

#ifdef CONFIG_SBUS
	if (err)
		platform_driver_unregister(&fore200e_sba_driver);
#endif

	return err;
}

static void __exit fore200e_module_cleanup(void)
{
#ifdef CONFIG_PCI
	pci_unregister_driver(&fore200e_pca_driver);
#endif
#ifdef CONFIG_SBUS
	platform_driver_unregister(&fore200e_sba_driver);
#endif
}

static int
fore200e_proc_read(struct atm_dev *dev, loff_t* pos, char* page)
{
    struct fore200e*     fore200e  = FORE200E_DEV(dev);
    struct fore200e_vcc* fore200e_vcc;
    struct atm_vcc*      vcc;
    int                  i, len, left = *pos;
    unsigned long        flags;

    if (!left--) {

	if (fore200e_getstats(fore200e) < 0)
	    return -EIO;

	len = sprintf(page,"\n"
		       " device:\n"
		       "   internal name:\t\t%s\n", fore200e->name);

	/* print bus-specific information */
	if (fore200e->bus->proc_read)
	    len += fore200e->bus->proc_read(fore200e, page + len);
	
	len += sprintf(page + len,
		"   interrupt line:\t\t%s\n"
		"   physical base address:\t0x%p\n"
		"   virtual base address:\t0x%p\n"
		"   factory address (ESI):\t%pM\n"
		"   board serial number:\t\t%d\n\n",
		fore200e_irq_itoa(fore200e->irq),
		(void*)fore200e->phys_base,
		fore200e->virt_base,
		fore200e->esi,
		fore200e->esi[4] * 256 + fore200e->esi[5]);

	return len;
    }

    if (!left--)
	return sprintf(page,
		       "   free small bufs, scheme 1:\t%d\n"
		       "   free large bufs, scheme 1:\t%d\n"
		       "   free small bufs, scheme 2:\t%d\n"
		       "   free large bufs, scheme 2:\t%d\n",
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_ONE ][ BUFFER_MAGN_LARGE ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_SMALL ].freebuf_count,
		       fore200e->host_bsq[ BUFFER_SCHEME_TWO ][ BUFFER_MAGN_LARGE ].freebuf_count);

    if (!left--) {
	u32 hb = fore200e->bus->read(&fore200e->cp_queues->heartbeat);

	len = sprintf(page,"\n\n"
		      " cell processor:\n"
		      "   heartbeat state:\t\t");
	
	if (hb >> 16 != 0xDEAD)
	    len += sprintf(page + len, "0x%08x\n", hb);
	else
	    len += sprintf(page + len, "*** FATAL ERROR %04x ***\n", hb & 0xFFFF);

	return len;
    }

    if (!left--) {
	static const char* media_name[] = {
	    "unshielded twisted pair",
	    "multimode optical fiber ST",
	    "multimode optical fiber SC",
	    "single-mode optical fiber ST",
	    "single-mode optical fiber SC",
	    "unknown"
	};

	static const char* oc3_mode[] = {
	    "normal operation",
	    "diagnostic loopback",
	    "line loopback",
	    "unknown"
	};

	u32 fw_release     = fore200e->bus->read(&fore200e->cp_queues->fw_release);
	u32 mon960_release = fore200e->bus->read(&fore200e->cp_queues->mon960_release);
	u32 oc3_revision   = fore200e->bus->read(&fore200e->cp_queues->oc3_revision);
	u32 media_index    = FORE200E_MEDIA_INDEX(fore200e->bus->read(&fore200e->cp_queues->media_type));
	u32 oc3_index;

	if (media_index > 4)
		media_index = 5;
	
	switch (fore200e->loop_mode) {
	    case ATM_LM_NONE:    oc3_index = 0;
		                 break;
	    case ATM_LM_LOC_PHY: oc3_index = 1;
		                 break;
	    case ATM_LM_RMT_PHY: oc3_index = 2;
		                 break;
	    default:             oc3_index = 3;
	}

	return sprintf(page,
		       "   firmware release:\t\t%d.%d.%d\n"
		       "   monitor release:\t\t%d.%d\n"
		       "   media type:\t\t\t%s\n"
		       "   OC-3 revision:\t\t0x%x\n"
                       "   OC-3 mode:\t\t\t%s",
		       fw_release >> 16, fw_release << 16 >> 24,  fw_release << 24 >> 24,
		       mon960_release >> 16, mon960_release << 16 >> 16,
		       media_name[ media_index ],
		       oc3_revision,
		       oc3_mode[ oc3_index ]);
    }

    if (!left--) {
	struct cp_monitor __iomem * cp_monitor = fore200e->cp_monitor;

	return sprintf(page,
		       "\n\n"
		       " monitor:\n"
		       "   version number:\t\t%d\n"
		       "   boot status word:\t\t0x%08x\n",
		       fore200e->bus->read(&cp_monitor->mon_version),
		       fore200e->bus->read(&cp_monitor->bstat));
    }

    if (!left--)
	return sprintf(page,
		       "\n"
		       " device statistics:\n"
		       "  4b5b:\n"
		       "     crc_header_errors:\t\t%10u\n"
		       "     framing_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->phy.crc_header_errors),
		       be32_to_cpu(fore200e->stats->phy.framing_errors));
    
    if (!left--)
	return sprintf(page, "\n"
		       "  OC-3:\n"
		       "     section_bip8_errors:\t%10u\n"
		       "     path_bip8_errors:\t\t%10u\n"
		       "     line_bip24_errors:\t\t%10u\n"
		       "     line_febe_errors:\t\t%10u\n"
		       "     path_febe_errors:\t\t%10u\n"
		       "     corr_hcs_errors:\t\t%10u\n"
		       "     ucorr_hcs_errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->oc3.section_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_bip8_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_bip24_errors),
		       be32_to_cpu(fore200e->stats->oc3.line_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.path_febe_errors),
		       be32_to_cpu(fore200e->stats->oc3.corr_hcs_errors),
		       be32_to_cpu(fore200e->stats->oc3.ucorr_hcs_errors));

    if (!left--)
	return sprintf(page,"\n"
		       "   ATM:\t\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     vpi out of range:\t\t%10u\n"
		       "     vpi no conn:\t\t%10u\n"
		       "     vci out of range:\t\t%10u\n"
		       "     vci no conn:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->atm.cells_transmitted),
		       be32_to_cpu(fore200e->stats->atm.cells_received),
		       be32_to_cpu(fore200e->stats->atm.vpi_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vpi_no_conn),
		       be32_to_cpu(fore200e->stats->atm.vci_bad_range),
		       be32_to_cpu(fore200e->stats->atm.vci_no_conn));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL0:\t\t\t     cells\n"
		       "     TX:\t\t\t%10u\n"
		       "     RX:\t\t\t%10u\n"
		       "     dropped:\t\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal0.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal0.cells_received),
		       be32_to_cpu(fore200e->stats->aal0.cells_dropped));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL3/4:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal34.cells_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cells_received),
		       be32_to_cpu(fore200e->stats->aal34.cells_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cells_crc_errors),
		       be32_to_cpu(fore200e->stats->aal34.cells_protocol_errors),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_transmitted),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_received),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_dropped),
		       be32_to_cpu(fore200e->stats->aal34.cspdus_protocol_errors));
    
    if (!left--)
	return sprintf(page,"\n"
		       "   AAL5:\n"
		       "     SAR sublayer:\t\t     cells\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       congestions:\t\t%10u\n\n"
		       "     CS  sublayer:\t\t      PDUs\n"
		       "       TX:\t\t\t%10u\n"
		       "       RX:\t\t\t%10u\n"
		       "       dropped:\t\t\t%10u\n"
		       "       CRC errors:\t\t%10u\n"
		       "       protocol errors:\t\t%10u\n",
		       be32_to_cpu(fore200e->stats->aal5.cells_transmitted),

MODULE_LICENSE("GPL");
#ifdef CONFIG_PCI
#ifdef __LITTLE_ENDIAN__
MODULE_FIRMWARE("pca200e.bin");
#else
MODULE_FIRMWARE("pca200e_ecd.bin2");
#endif
#endif /* CONFIG_PCI */
#ifdef CONFIG_SBUS
MODULE_FIRMWARE("sba200e_ecd.bin2");
#endif